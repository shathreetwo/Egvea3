class Boss(Widget):
    boss_type = NumericProperty(1)
    phase = NumericProperty(1)
    pattern_index = NumericProperty(0)
    health = NumericProperty(100)

    def __init__(self,  boss_type=1, game_screen=None, **kwargs):
        #self.boss_type = kwargs.pop('boss_type', 1)  # ì¸ìë¡œ ë°›ìŒ
        super().__init__(**kwargs)
        self.game_screen = game_screen
        self.size = (120, 120)
        self.size_hint = (None, None)  # í•„ìˆ˜: í¬ê¸° ê³ ì • ì•ˆ í•˜ë©´ ë¶€ëª¨ í¬ê¸° ë”°ë¼ê°
        self.pattern_timer = 0

        with self.canvas:
            Color(0.6, 0, 0.6)
            self.rect = Rectangle(pos=self.pos, size=self.size)

        self.bind(pos=self.update_graphics)

        # ğŸ’¡ íŒ¨í„´ì„ ë³´ìŠ¤ íƒ€ì…ì— ë”°ë¼ ë‹¤ë¥´ê²Œ êµ¬ì„±
        if self.boss_type == 1:
            self.patterns = [self.pattern_straight_bullets]
        elif self.boss_type == 2:
            self.patterns = [self.pattern_spread_bullets, self.pattern_straight_bullets]
        else:
            self.patterns = [self.pattern_straight_bullets]

        # íŒ¨í„´ ë°˜ë³µ í˜¸ì¶œ
        #Clock.schedule_interval(self.attack, 1.5)



    def update_graphics(self, *args):
        self.rect.pos = self.pos
        
    def move(self, dt):
        pass  # í˜„ì¬ëŠ” ì›€ì§ì´ì§€ ì•ŠìŒ

    def update(self, dt):
        self.pattern_timer += dt
        if self.pattern_timer > 2:
            self.patterns[self.pattern_index % len(self.patterns)]()
            self.pattern_index += 1
            self.pattern_timer = 0
        self.y -= 0.5  # ë³´ìŠ¤ ì´ë™

    def pattern_straight_bullets(self):
        # ë³´ìŠ¤ ìœ„ì¹˜ ì¤‘ì•™ì—ì„œ ì•„ë˜ë¡œ ì¼ì§ì„  ì´ì•Œ ì—¬ëŸ¬ ë°œ
        for offset in range(-60, 61, 30):  # -60, -30, 0, 30, 60
            bullet = EnemyBullet2(
                pos=(self.center_x + offset, self.y),
                direction=(0, -1)
            )
            self.game_screen.enemy_bullets.append(bullet)
            self.game_screen.layout.add_widget(bullet)

    def pattern_spread_bullets(self):
        # ì—¬ëŸ¬ ë°©í–¥ìœ¼ë¡œ í¼ì§€ëŠ” ì´ì•Œ
        for angle_deg in range(210, 331, 15):  # ì•„ë˜ ë°˜ì› ë°©í–¥
            angle = radians(angle_deg)
            bullet = EnemyBullet2(
                pos=(self.center_x, self.y),
                direction=(cos(angle), sin(angle))
            )
            self.game_screen.enemy_bullets.append(bullet)
            self.game_screen.layout.add_widget(bullet)

    def pattern_target_player(self):
        if not hasattr(self.game_screen, "ship"):
            return
        player = self.game_screen.ship
        dx = player.center_x - self.center_x
        dy = player.center_y - self.center_y
        length = max((dx**2 + dy**2)**0.5, 0.1)
        direction = (dx / length, dy / length)

        bullet = EnemyBullet2(
            pos=(self.center_x, self.y),
            direction=direction
        )
        self.game_screen.enemy_bullets.append(bullet)
        self.game_screen.layout.add_widget(bullet)

    def attack(self, dt):
        for pattern in self.patterns:
            pattern()
        
    def take_damage(self, amount):
        self.health -= amount
        if self.health <= 0:
            self.defeated()

    def defeated(self):
        print("ğŸ‰ ë³´ìŠ¤ ê²©íŒŒ!")
        self.parent.remove_widget(self)




class GameScreen(Screen):
    selected_ship = NumericProperty(1)
    enemies = ListProperty([])

    def on_enter(self):
        self.clear_widgets()
        self.layout = FloatLayout(size_hint=(1, 1))
        self.add_widget(self.layout)
        self.init_game()
        self.enemy_bullets = []  # on_enterë‚˜ init_gameì—ì„œ ì´ˆê¸°í™”
        #self.boss = None  # ğŸ› ï¸ ì—¬ê¸° ì¶”ê°€!
        self.boss = Boss(boss_type=2, game_screen=self)
        Clock.schedule_once(self.spawn_boss, 10)
        


    def init_game(self):
        self.ship = SpaceShip(ship_type=self.selected_ship, pos=(self.width / 2 - 25, 50))
        self.layout.add_widget(self.ship)

        self.enemy_spawn_event = Clock.schedule_interval(self.spawn_enemy, 2)
        #Clock.schedule_interval(self.spawn_enemy, 2)
        Clock.schedule_interval(self.update, 1 / 60)

        self.dragging = False
        self.touch_offset = (0, 0)

    def spawn_enemy(self, dt):
        enemy_type = randint(1, 3)
        x = randint(0, int(self.width - 40))
        enemy = Enemy(pos=(x, self.height), enemy_type=enemy_type, target=self.ship)
        self.enemies.append(enemy)
        self.layout.add_widget(enemy)
        #print(f"Spawned enemy type {enemy_type} at {enemy.pos} with size {enemy.size}")

    def update(self, dt):
        for enemy in self.enemies[:]:
            enemy.move(dt)
            #print(f"Enemy type {enemy.enemy_type} at {enemy.pos}, size {enemy.size}")
            if self.ship.collide_widget(enemy):
                print(f"ğŸ’¥ ì¶©ëŒ! ê²Œì„ ì˜¤ë²„! ì  ì¢…ë¥˜: {enemy.enemy_type}, ì  ìœ„ì¹˜: {enemy.pos}, ìš°ì£¼ì„  ìœ„ì¹˜: {self.ship.pos}")
                self.enemies.remove(enemy)
                self.layout.remove_widget(enemy)
                self.game_over()
                return

            if enemy.y < 0:
                self.enemies.remove(enemy)
                self.layout.remove_widget(enemy)

                
        for bullet in self.enemy_bullets[:]:
            bullet.move()
            #print(f"Bullet pos: {bullet.pos}, size: {bullet.size}")
            #print(f"Ship pos: {self.ship.pos}, size: {self.ship.size}")
            if bullet.y < -20:
                self.enemy_bullets.remove(bullet)
                self.remove_widget(bullet)
            elif bullet.collide_widget(self.ship):
                print("Ship hit by visible bullet!")
                self.game_over()

        if self.boss:
            self.boss.move(dt)

            if self.ship.collide_widget(self.boss):
                print("ğŸ’¥ ë³´ìŠ¤ì™€ ì¶©ëŒ! ê²Œì„ ì˜¤ë²„!")
                self.game_over()

            # ë‚˜ì¤‘ì— ì´ì•Œ ì¶©ëŒ ì²˜ë¦¬ë‚˜ ì²´ë ¥ UI ë“± ì¶”ê°€ ê°€ëŠ¥
                
    def game_over(self):
        Clock.unschedule(self.update)
        Clock.unschedule(self.spawn_enemy)
        print("ê²Œì„ ì˜¤ë²„!")
        # í•„ìš”ì‹œ label ì¶”ê°€ ë˜ëŠ” í™”ë©´ ì „í™˜ ê°€ëŠ¥
        # ìš°ì£¼ì„  ì‚­ì œ
        self.layout.remove_widget(self.ship)

        # í˜¹ì€ ë©ˆì¶”ê¸°ë§Œ í•˜ê³  ì‹¶ë‹¤ë©´:
        # self.ship.dragging = False
        # self.dragging = False

    def on_touch_down(self, touch):
        # í•­ìƒ ë“œë˜ê·¸ ì‹œì‘ìœ¼ë¡œ ì²˜ë¦¬
        self.dragging = True
        self.touch_offset = (touch.x - self.ship.x, touch.y - self.ship.y)
        return True

    def on_touch_move(self, touch):
        if self.dragging:
            new_x = touch.x - self.touch_offset[0]
            new_y = touch.y - self.touch_offset[1]

            max_x = self.width - self.ship.width
            max_y = self.height - self.ship.height

            new_x_clamped = max(0, min(new_x, max_x))
            new_y_clamped = max(0, min(new_y, max_y))

            self.ship.pos = (new_x_clamped, new_y_clamped)
            return True
        return super().on_touch_move(touch)

    def on_touch_up(self, touch):
        self.dragging = False
        return True
    
    def shoot(self, pos):
        bullet = EnemyBullet(pos=pos)
        self.enemy_bullets.append(bullet)
        self.layout.add_widget(bullet)

    def spawn_boss(self, dt):
        boss_type = randint(1, 2)
        self.boss = Boss(boss_type=boss_type)
        self.layout.add_widget(self.boss)
        self.boss.center_x = self.width / 2
        self.boss.top = self.height - 20
        print(f"ğŸš¨ ë³´ìŠ¤ ë“±ì¥! íƒ€ì…: {boss_type}")

        # ì¼ë°˜ ì  ìŠ¤í° ì¤‘ë‹¨
        if hasattr(self, 'enemy_spawn_event'):
            Clock.unschedule(self.enemy_spawn_event)

        self.start_boss()

    def start_boss(self):
        # ë³´ìŠ¤ íŒ¨í„´ ì‹œì‘ (ë³´ìŠ¤ê°€ ì´ë¯¸ ìƒì„±ë˜ê³  ë¶€ëª¨ì— ì¶”ê°€ëœ í›„)
        Clock.schedule_interval(self.boss.attack, 1.5)
